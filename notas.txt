KeyFactory kf = KeyFactory.getInstance("EC", curve.kfProvider);
PKCS8EncodedKeySpec kfs = kf.getKeySpec(key.getPrivate(), PKCS8EncodedKeySpec.class);
System.out.println("-----BEGIN PRIVATE KEY-----");
System.out.println(com.sun.org.apache.xml.internal.security.utils.Base64.encode(kfs.getEncoded()));
System.out.println("-----END PRIVATE KEY-----");

openssl pkcs8 -nocrypt -in pr.key -outform DER | hexdump -v -e '16/1 "0x%02x, " "\n"'

pasar el resultado a C++

1. pasar la EC_KEY a EVP_KEY y luego llamar a PEM_write_bio_PUBKEY para obtener la clave pública
EC_KEY >
EVP_PKEY_set1_EC_KEY()
EVP_PKEY *tpubkey; > SOLO LA CLAVE PUBLICA
i2d_PUBKEY(tpubkey, pp)
datos binarios void *x

EVP_PKEY *keypair
X509_PUBKEY_set() pasamos a
X509_PUBKEY, de aquí
X509_PUBKEY_get() pasamos a
EVP_PKEY *pubkey
i2d_PUBKEY(tpubkey, pp)
datos binarios void *x


X509_REQ_get_pubkey(req)
  X509_PUBKEY_get()
PEM_write_bio_PUBKEY
  EVP_EncodeUpdate
    EVP_EncodeBlock
i2d *(
data: 0x7adcf0

ECPublicKeyImpl key byte[65], encodedKey byte[91]
por alguna razón da error al importar la clave privada al boringssl ? No está en formato PKCS8 DER

Estrategia:
1. Verificar que el AES-256-CFB8 sea el mismo modo que el de Freenet
1.1 Hacer el mismo test que encryptor_unittests.cc usando manualmente la librería openssl. Pasar 5 tests y apuntar los criptogramas
1.2 Hacer los mismos tests en Java. Mirar que los criptogramas coincidan
2. Adaptar crypto/encryptor_openssl.cc para añadir el nuevo modo CFB.
3. Añadir el nuevo modo en los archivos relacionados del boringssl copiándolo si es necesario del openssl

AES-256-CFB8
third_party/boringssl/src/crypto/modes/cfb.c
third_party/boringssl/src/crypto/obj/obj_dat.h
crypto/encryptor_openssl.cc

boringssl/src/crypto/cipher/e_aes.c
= openssl-1.0.1j/crypto/evp/e_aes.c

boringssl/src/crypto/cipher/cipher.c
= openssl-1.0.1j/crypto/evp/evp_enc.c

